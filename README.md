Download Link: https://assignmentchef.com/product/solved-the-seaport-project-series-project-2
<br>
<p class="ui header product-top-header" title="The SeaPort Project Series Solution">For this set of projects for the course, we wish to simulate some of the aspects of a number of Sea Ports.Here are the classes and their instance variables we wish to define: SeaPortProgram extends JFrame o variables used by the GUI interface o world: World Thing implement Comparable &lt;Thing o index: int o name: String o parent: int World extends Thing o ports: ArrayList &lt;SeaPort o time: PortTime  SeaPort extends Thing o docks: ArrayList &lt;Dock o que: ArrayList &lt;Ship // the list of ships waiting to dock o ships: ArrayList &lt;Ship // a list of all the ships at this port o persons: ArrayList &lt;Person // people with skills at this port  Dock extends Thing o ship: Ship  Ship extends Thing o arrivalTime, dockTime: PortTime o draft, length, weight, width: double o jobs: ArrayList &lt;Job  PassengerShip extends Ship o numberOfOccupiedRooms: int o numberOfPassengers: int o numberOfRooms: int  CargoShip extends Ship o cargoValue: double o cargoVolume: double o cargoWeight: double  Person extends Thing o skill: String  Job extends Thing – optional till Projects 3 and 4 o duration: double o requirements: ArrayList &lt;String // should be some of the skills of the persons  PortTime o time: intEventually, in Projects 3 and 4, you will be asked to show the progress of the jobs using JProgressBar’s.

Here’s a very quick overview of all projects:

1. Read a data file, create the internal data structure, create a GUI to display the structure, and let the user search the structure. 2. Sort the structure, use hash maps to create the structure more efficiently. 3. Create a thread for each job, cannot run until a ship has a dock, create a GUI to show the progress of each job. 4. Simulate competing for resources (persons with particular skills) for each job.

<strong>Project 2 – Map class, Comparator, sorting</strong>

 Use the JDK Map class to write more efficient code when constructing the internal data structures from the data file.  Implement SORTING using the Comparator interface together with the JDK support for sorting data structures, thus sorting on different fields of the classes from Project 1.  Extend the GUI from Project 1 to let the user sort the data at run-time.

<strong>Documentation Requirements:</strong>

You should start working on a documentation file before you do anything else with these projects, and fill in items as you go along. Leaving the documentation until the project is finished is not a good idea for any number of reasons.The documentation should include the following (graded) elements: Cover page (including name, date, project, your class information)  Design o including a UML class diagram o classes, variables and methods: what they mean and why they are there o tied to the requirements of the project  User’s Guide o how would a user start and run your project o any special features o effective screen shots are welcome, but don’t overdo this  Test Plan o do this BEFORE you code anything o what do you EXPECT the project to do o justification for various data files, for example  Lessons Learned o express yourself here o a way to keep good memories of successes after hard work

Extend Project 1 to use advanced data structures and support sorting on various keys.1. Required data structure – the data structure specified in Project 1: a. World has SeaPort’s b. SeaPort has Dock’s, Ship’s, and Person’s c. Dock has a Ship d. Ship has Job’s e. PassengerShip f. CargoShip g. Person has a skill h. Job requires skills – optional until Project 3 i. PortTime 2. Use the HashMap class to support efficient linking of the classes used in Project 1. 1. The instances of the hash map class should be local to the readFile (Scanner) method. 2. These instances should be passed as explicit parameters to other methods used when reading the data file. 1. For example, the body of the methods like the following should be replaced to effectively use a &lt;Integer, Ship hash map, the surrounding code needs to support this structure: Ship getShipByIndex (int x, java.util.HashMap &lt;Integer, Ship hms) { return hms.get(x); } // end getDockByIndex 2. Since the body of this method has become trivial, perhaps the call to this method can be simply replaced by the get method of the HashMap. 3. Your code should be sure to handle a null return from this call gracefully. 3. The instances should be released (go out of scope, hence available for garbage collection) when the readFile method returns. 4. Comments: The idea here, besides getting some experience with an interesting JDK Collections class, is to change the operation of searching for an item with a particular index from an O(N) operation, ie searching through the entire data structure to see if the code can find the parent index parameter, to an O(1) operation, a hash map lookup. Of course, this isn’t so very interesting in such a small program, but consider what might happen with hundreds of ports, thousands of ships, and perhaps millions of persons and jobs. 5. Comments: Also, after the readFile operation, the indices are no longer interesting, and could be completely eliminated from the program. In this program, removing the index references could be accomplished by removing those variables from the parent class, Thing. 3. Implement comparators to support sorting: o ships in port que ArrayList’s by weight, length, width, draft within their port que o all items withing their ArrayList’s by name o OPTIONALLY: sorting by any other field that can be compared o The sorting should be within the parent ArrayList 4. Extend the GUI from Project 1 to allow the user to: o sort by the comparators defined above. 5. Again, the GUI elements should be distinct from the other classes in the program.